-- Required services
local userInputService = game:GetService("UserInputService")
local virtualInputManager = game:GetService("VirtualInputManager")
local players = game:GetService("Players")
local localPlayer = players.LocalPlayer
local workspacePlayers = workspace:WaitForChild("Players")
local workspaceHoops = workspace:WaitForChild("Hoops")
local workspaceBalls = workspace:WaitForChild("Balls")

-- Create a ScreenGui for the toggle indicators
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "ToggleIndicators"
screenGui.Parent = localPlayer:WaitForChild("PlayerGui")

-- Variable to control the script state
local scriptActive = true

-- Function to create a toggle indicator UI dot at the bottom right
local function createIndicator(name, positionOffset)
    local indicator = Instance.new("Frame")
    indicator.Size = UDim2.new(0, 1, 0, 1) -- Small dot size
    indicator.AnchorPoint = Vector2.new(1, 1) -- Anchor to the bottom-right corner
    indicator.Position = UDim2.new(1, -1 - positionOffset, 1, -1) -- Position offset from the bottom right
    indicator.BackgroundColor3 = Color3.new(1, 0, 0) -- Red when inactive
    indicator.BorderSizePixel = 0
    indicator.Name = name .. "Indicator"
    indicator.Parent = screenGui
    return indicator
end

-- Create indicators with specific offsets for positioning in the bottom-right corner
local indicators = {
    Guard2 = createIndicator("Guard2", 0),          -- First dot from the right
    Block = createIndicator("Block", 4),           -- Next dot to the left
    Bar = createIndicator("Bar", 8),               -- Next dot to the left
    PredictLanding = createIndicator("PredictLanding", 12) -- Furthest dot to the left
}

-- Function to update indicator color based on toggle state
local function updateIndicator(name, state)
    indicators[name].BackgroundColor3 = state and Color3.new(0, 1, 0) or Color3.new(1, 0, 0) -- Green if active, red if inactive
end

-- Toggle state variables
_G.guard2 = false
_G.block = false
_G.e = false
_G.predictLanding = false

-- Keybindings and toggle functions
local toggleKeys = {
    [Enum.KeyCode.PageUp] = function() -- Toggle Guard2
        _G.guard2 = not _G.guard2
        -- print("Guard2 toggle:", _G.guard2 and "enabled" or "disabled")
        updateIndicator("Guard2", _G.guard2)
    end,
    [Enum.KeyCode.PageDown] = function() -- Toggle Block
        _G.block = not _G.block
        -- print("Block toggle:", _G.block and "enabled" or "disabled")
        updateIndicator("Block", _G.block)
    end,
    [Enum.KeyCode.Home] = function() -- Toggle Bar
        _G.e = not _G.e
        -- print("Bar toggle:", _G.e and "enabled" or "disabled")
        updateIndicator("Bar", _G.e)
    end,
    [Enum.KeyCode.End] = function() -- Toggle PredictLanding
        _G.predictLanding = not _G.predictLanding
        -- print("PredictLanding toggle:", _G.predictLanding and "enabled" or "disabled")
        updateIndicator("PredictLanding", _G.predictLanding)
    end,
    [Enum.KeyCode.F10] = function() -- Reset everything and stop further input
        -- Untoggle all states
        _G.guard2 = false
        _G.block = false
        _G.e = false
        _G.predictLanding = false

        -- Clear all indicators and remove ScreenGui
        screenGui:Destroy()

        -- Stop further input and terminate script
        scriptActive = false
        -- print("All toggles reset, UI cleared, and script terminated.")
    end
}

-- Listen for key inputs to toggle functions
userInputService.InputBegan:Connect(function(input, gameProcessed)
    if scriptActive and not gameProcessed and toggleKeys[input.KeyCode] then
        toggleKeys[input.KeyCode]()
    end
end)

-- Required services
local workspacePlayers = workspace:WaitForChild("Players")
local workspaceBalls = workspace:WaitForChild("Balls")
local virtualInputManager = game:GetService("VirtualInputManager")
local playerModel = workspacePlayers:FindFirstChild(game.Players.LocalPlayer.Name)

-- Threshold distance (you can adjust this value)
local thresholdDistance = 1.06
local playerDistanceThreshold = 12

local blockingAnimations = {
    "Fade",
    "Dunk",
    "Jumper",
    "Hook",
    "Moving"
}

local specialIds = {
    "rbxassetid://16154147726",
    "rbxassetid://16153893144",
    "rbxassetid://15230192060", 
    "rbxassetid://15239809644",
    "rbxassetid://14257782487",
    "rbxassetid://15232035047",
    "rbxassetid://15490828826"
}

local reachIds = {
    "rbxassetid://15412469030",
    "rbxassetid://15412463547"
}

local hopAnimations = {
    "rbxassetid://15469060935",
    "rbxassetid://15469074288"
}

local originalBallSize
-- Clone balls, inherit original sizes for clones, and reset original sizes after 3 seconds
local function cloneBalls()
    local clones = {}

    -- Adjust original balls to 3,3,3 and create clones with original sizes
    for _, ball in pairs(workspaceBalls:GetChildren()) do
        print(ball:FindFirstChild("Ball"))
        if ball:IsA("BasePart") and ball.Name == "Ball" and ball:FindFirstChild("Ball") == nil then
            -- Clone the ball and set it to the original size
            local clone = ball:Clone()
            originalBallSize = ball.Size -- Set clone to the same size as the original
            clone.Parent = ball
            table.insert(clones, clone)

            -- Create a WeldConstraint to keep the clone at the same position and rotation as the original ball
            local weld = Instance.new("WeldConstraint")
            weld.Part0 = ball -- Attach to the original ball
            weld.Part1 = clone -- Attach to the clone
            weld.Parent = ball -- Parent the weld to the original ball
            weld.Enabled = true

            ball.Transparency = 0.5
            ball.Size = Vector3.new(4,4,4) -- Set the original ball size to 3,3,3
        end
    end

    -- Remove all clones and reset original ball sizes after 3 seconds
    task.delay(1, function()
        for _, ball in pairs(workspaceBalls:GetChildren()) do
            if ball:IsA("BasePart") and ball.Name == "Ball" then
                ball.Transparency = 0
                ball.Size = Vector3.new(1.244503140449524, 1.244503140449524, 1.244503140449524) -- Set the original ball size to 3,3,3
            end
        end

        for _, clone in pairs(clones) do
            if clone then
                clone:Destroy()
            end
        end
    end)
end

-- Function to find the closest ball
local function getClosestBall(referencePosition)
    local closestBall = nil
    local shortestDistance = math.huge

    for _, ball in pairs(workspaceBalls:GetChildren()) do
        if ball:IsA("BasePart") and ball.Name == "Ball" then
            local distance = (ball.Position - referencePosition).Magnitude
            if distance < shortestDistance then
                shortestDistance = distance
                closestBall = ball
            end
        end
    end

    return closestBall, shortestDistance
end

local function getNearestHoop(position)
    local closestHoop = nil
    local shortestDistanceToHoop = math.huge

    -- Iterate over all players to find the one closest to the closest ball !!NAME
    for _, hoop in pairs(workspaceHoops:GetChildren()) do
        if hoop.Name == "Hoop" then
            print(hoop.AimPart.Position)
            local distanceToHoop = (hoop.AimPart.Position - position).Magnitude
            if distanceToHoop < shortestDistanceToHoop then
                shortestDistanceToHoop = distanceToHoop
                closestHoop = hoop
            end
        end
    end
    return closestHoop, shortestDistanceToHoop
end

-- Modified cloneBalls function to operate only on the nearest ball
local function cloneNearestBall(referencePosition)
    -- Find the closest ball to the reference position
    local closestBall, shortestDistance = getClosestBall(referencePosition)
    
    if closestBall and closestBall:FindFirstChild("Ball") == nil then
        -- Clone the ball and adjust its size
        local clone = closestBall:Clone()
        originalBallSize = closestBall.Size -- Save the original size
        clone.Parent = closestBall
        clone.Name = "Clone"

        -- Create a WeldConstraint to keep the clone at the same position and rotation as the original ball
        local weld = Instance.new("WeldConstraint")
        weld.Part0 = closestBall -- Attach to the original ball
        weld.Part1 = clone -- Attach to the clone
        weld.Parent = closestBall -- Parent the weld to the original ball
        weld.Enabled = true

        -- Modify the original ball's appearance and size
        closestBall.Transparency = 0.5
        closestBall.Size = Vector3.new(4, 4, 4) -- Enlarged size for visualization

        -- Remove the clone and reset the original ball size after 3 seconds
        task.delay(3, function()
            if closestBall and closestBall:IsDescendantOf(workspaceBalls) then
                closestBall.Transparency = 0
                closestBall.Size = Vector3.new(1.244503140449524, 1.244503140449524, 1.244503140449524) -- Set the original ball size to 3,3,3
            end
            if clone then
                clone:Destroy()
                weld:Destroy()
            end
        end)
    end
end



-- Modified function to find the closest player to the closest ball
local function getClosestPlayerToBall()
    local localPlayer = workspacePlayers:FindFirstChild(game.Players.LocalPlayer.Name)
    if not localPlayer then return end

    local head = localPlayer:FindFirstChild("Head")
    if not head then return end

    -- Find the closest ball to the local player's head position
    local closestBall, ballDistance = getClosestBall(head.Position)
    if not closestBall then return end

    local closestPlayer = nil
    local shortestDistanceToBall = math.huge

    -- Iterate over all players to find the one closest to the closest ball 
    for _, player in pairs(workspacePlayers:GetChildren()) do
        if player:IsA("Model") and player.Name ~= localPlayer.Name then
            local playerHead = player:FindFirstChild("Head")
            if playerHead then
                local distanceToBall = (closestBall.Position - playerHead.Position).Magnitude
                if distanceToBall < shortestDistanceToBall then
                    shortestDistanceToBall = distanceToBall
                    closestPlayer = player
                end
            end
        end
    end
    return closestPlayer, closestBall
end

-- Function to check if any blocking animation is running on a player
local function isBlocking(player)
    local humanoid = player:FindFirstChildOfClass("Humanoid")
    if humanoid then
        local animator = humanoid:FindFirstChildOfClass("Animator")
        if animator then
            for _, track in pairs(animator:GetPlayingAnimationTracks()) do
                print("Playing Animation:", track)
                if track.Animation then
                    for _, keyword in ipairs(blockingAnimations) do
                        if string.find(track.Animation.Name, keyword) then
                            return true 
                        end
                    end
                end
            end
        end
    end
    return false
end

-- Function to check if any hop animation is running on a player
local function isHopping(player)
    local humanoid = player:FindFirstChildOfClass("Humanoid")
    if humanoid then
        local animator = humanoid:FindFirstChildOfClass("Animator")
        if animator then
            for _, track in pairs(animator:GetPlayingAnimationTracks()) do
                if table.find(hopAnimations, track.Animation.AnimationId) then
                    return true
                end
            end
        end
    end
    return false
end

local function isSpecial(player)
    local humanoid = player:FindFirstChildOfClass("Humanoid")
    if humanoid then
        local animator = humanoid:FindFirstChildOfClass("Animator")
        if animator then
            for _, track in pairs(animator:GetPlayingAnimationTracks()) do
                if table.find(specialIds, track.Animation.AnimationId) then
                    return true
                end
            end
        end
    end
    return false
end

local function isReaching(player)
    local humanoid = player:FindFirstChildOfClass("H umanoid")
    if humanoid then
        local animator = humanoid:FindFirstChildOfClass("Animator")
        if animator then
            for _, track in pairs(animator:GetPlayingAnimationTracks()) do
                if table.find(reachIds, track.Animation.AnimationId) then
                    return true
                end
            end
        end
    end
    return false
end

-- Block functionality loop
spawn(function()
    while scriptActive do
        if _G.block then
            -- Block functionality: Trigger blocking action based on proximity to other players and balls
            if userInputService:IsKeyDown(Enum.KeyCode.L) then
                local closestPlayer, closestBall = getClosestPlayerToBall()
                local localPlayer = workspacePlayers:FindFirstChild(game.Players.LocalPlayer.Name)
                local localHead = localPlayer and localPlayer:FindFirstChild("Head")
                local closestPlayerHead = closestPlayer and closestPlayer:FindFirstChild("Head")
                local closestBall = getClosestBall(localPlayer.HumanoidRootPart.Position)
                if localHead and closestPlayerHead then
                    local lp = game:GetService("Players")[closestPlayer.Name]
                    local distanceBetweenPlayers = (localHead.Position - closestPlayerHead.Position).Magnitude
                    local humanoidRootPart = closestPlayer:FindFirstChild("HumanoidRootPart")
                    local lookDirection = humanoidRootPart.CFrame.LookVector
                    local offset = 3.5 -- Adjust this value for the desired distance in front
                    local targetPosition = humanoidRootPart.Position + (lookDirection * offset)
                    if distanceBetweenPlayers < playerDistanceThreshold and lp then
                        if closestPlayer:GetAttribute("Dunking") then
                            print("Light")
                            wait(0.1)
                            virtualInputManager:SendKeyEvent(true, Enum.KeyCode.LeftShift, false, game)
                            localPlayer:FindFirstChildOfClass("Humanoid"):MoveTo(targetPosition)
                            task.wait(0.19)
                            -- print("blocked")
                            virtualInputManager:SendKeyEvent(true, Enum.KeyCode.Space, false, game)
                            wait(0.05)
                            virtualInputManager:SendKeyEvent(false, Enum.KeyCode.Space, false, game)
                        end
                        -- if not closestPlayer:GetAttribute("Dunking") and closestPlayer:GetAttribute("Shooting") and lp:GetAttribute("MeterActive") == true and lp:GetAttribute("Meter") > 0.4 then
                        --     print("Heavy")
                        --     wait(0.1)
                        --     virtualInputManager:SendKeyEvent(true, Enum.KeyCode.LeftShift, false, game)
                        --     localPlayer:FindFirstChildOfClass("Humanoid"):MoveTo(targetPosition)
                        --     task.wait(0.22)
                        --     -- print("blocked")
                        --     virtualInputManager:SendKeyEvent(true, Enum.KeyCode.Space, false, game)
                        --     wait(0.05)
                        --     virtualInputManager:SendKeyEvent(false, Enum.KeyCode.Space, false, game)
                        -- end
                    end
                end
            end
        end
        wait(0.01) -- Slight yield for performance
    end
end)

-- Guard2 functionality loop
spawn(function()
    while scriptActive do
        if _G.guard2 then
            -- Guard2 functionality: Check for closest player to a ball and press "G" if conditions are met
            local closestPlayer, closestBall = getClosestPlayerToBall()
            local localPlayer = workspacePlayers:FindFirstChild(game.Players.LocalPlayer.Name)
            local localHead = localPlayer and localPlayer:FindFirstChild("Head")
            local closestPlayerHead = closestPlayer and closestPlayer:FindFirstChild("Head")
            local localPlayer2 = game.Players.LocalPlayer
            -- print("Hi")

            if closestPlayer and localHead and closestPlayerHead then
                local lp = game:GetService("Players")[closestPlayer.Name]
                if lp then
                    -- local humanoidRootPart = closestPlayer:FindFirstChild("HumanoidRootPart")
                    -- local lookDirection = humanoidRootPart.CFrame.LookVector
                    -- local offset = 0.5 -- Adjust this value for the desired distance in front
                    -- local targetPosition = humanoidRootPart.Position + (lookDirection * offset)
                    -- print(lp.Name)
                    if (lp.Team ~= localPlayer2.Team) or (lp.Neutral == true) then
                        local distanceBetweenPlayers = (localHead.Position - closestPlayerHead.Position).Magnitude
                        -- print(distanceBetweenPlayers)
                        -- print(lp:GetAttribute("MeterActive"))
                        -- print(lp:GetAttribute("Meter"))
                        local nearPlayer, dist1 = getNearestHoop(closestPlayerHead.Position)
                        local myPlayer, dist2 = getNearestHoop(localHead.Position)
                        print(dist1, dist2)
                        if distanceBetweenPlayers < 14 and dist2 < dist1 + 5 then
                            if lp:GetAttribute("MeterActive") == true and lp:GetAttribute("Meter") > 0.1 then
                                task.wait((math.random(0, 10) / 100))
                                -- print("guarded") 
                                -- local args = {
                                --     [1] = {
                                --         ["Action"] = "Guarding",
                                --         ["Val"] = true
                                --     }
                                -- }

                                -- game:GetService("ReplicatedStorage").Lib.EventsPlayer.Actions:FireServer(unpack(args))
                                virtualInputManager:SendKeyEvent(true, Enum.KeyCode.G, false, game)
                                -- local args = {
                                --     [1] = {
                                --         ["Action"] = "Guarding",
                                --         ["Val"] = true
                                --     }
                                -- }

                                -- game:GetService("ReplicatedStorage").Lib.EventsPlayer.Actions:FireServer(unpack(args))
                                -- localPlayer:FindFirstChildOfClass("Humanoid"):MoveTo(targetPosition)
                                wait(1)
                                virtualInputManager:SendKeyEvent(false, Enum.KeyCode.G, false, game)
                                -- local args = {
                                --     [1] = {
                                --         ["Action"] = "Guarding",
                                --         ["Val"] = false
                                --     }
                                -- }

                                -- game:GetService("ReplicatedStorage").Lib.EventsPlayer.Actions:FireServer(unpack(args))
                            end
                        end
                    end
                else
                    -- print("Player instance not found in Players service.")
                end
            else
                if not closestPlayer then
                    -- print("No closest player found.")
                end
                if not localHead then
                    -- print("Local player's head not found.")
                end
                if not closestPlayerHead then
                    -- print("Closest player's head not found.")
                end
            end
        end
        wait(0.01) -- Slight yield for performance
    end
end)

-- Bar functionality loop
spawn(function()
    while scriptActive do
        if _G.e then
            -- Bar functionality: Disable E and Space keys if a certain "Meter" attribute is above a threshold
            if players.LocalPlayer:GetAttribute("Meter") >= 0.80 then
                local args = {
                    [1] = {
                        ["Action"] = "StopMeter",
                        ["PumpFake"] = false
                    }
                }
                
                game:GetService("ReplicatedStorage"):WaitForChild("Lib"):WaitForChild("EventsPlayer"):WaitForChild("Actions"):FireServer(unpack(args))
                wait(0.05)
                local args = {
                    [1] = {
                        ["Action"] = "StopMeter",
                        ["PumpFake"] = false
                    }
                }
                
                game:GetService("ReplicatedStorage"):WaitForChild("Lib"):WaitForChild("EventsPlayer"):WaitForChild("Actions"):FireServer(unpack(args))
                wait(0.3)
                local args = {
                    [1] = {
                        ["Action"] = "ShootBall",
                        ["ClientTime"] = 0
                    }
                }
                
                game:GetService("ReplicatedStorage"):WaitForChild("Lib"):WaitForChild("EventsPlayer"):WaitForChild("Actions"):FireServer(unpack(args))                                                
                -- print("Bar action triggered")
            end
        end
        wait(0.01) -- Slight yield for performance
    end
end)

spawn(function()
    while scriptActive do
        if _G.predictLanding then
        --     local localPlayer = workspacePlayers:FindFirstChild(game.Players.LocalPlayer.Name)
        --     if not localPlayer then return end
        --     local head = localPlayer:FindFirstChild("Head")
        --     if not head then return end
        --     if isReaching(workspacePlayers[game.Players.LocalPlayer.Name]) then
        --         -- Find the closest ball to the reference position
        --         local closestBall, shortestDistance = getClosestBall(head.Position)
                
        --         if closestBall and closestBall:FindFirstChild("Ball") == nil then
        --             -- Clone the ball and adjust its size
        --             local clone = closestBall:Clone()
        --             originalBallSize = closestBall.Size -- Save the original size
        --             clone.Parent = closestBall
        --             clone.Name = "Clone"

        --             -- Create a WeldConstraint to keep the clone at the same position and rotation as the original ball
        --             local weld = Instance.new("WeldConstraint")
        --             weld.Part0 = closestBall -- Attach to the original ball
        --             weld.Part1 = clone -- Attach to the clone
        --             weld.Parent = closestBall -- Parent the weld to the original ball
        --             weld.Enabled = true

        --             -- Modify the original ball's appearance and size
        --             closestBall.Transparency = 0.5
        --             closestBall.Size = Vector3.new(4, 4, 4) -- Enlarged size for visualization

        --             -- Remove the clone and reset the original ball size after 3 seconds
        --             task.delay(3, function()
        --                 if closestBall and closestBall:IsDescendantOf(workspaceBalls) then
        --                     closestBall.Transparency = 0
        --                     closestBall.Size = Vector3.new(1.244503140449524, 1.244503140449524, 1.244503140449524) -- Set the original ball size to 3,3,3
        --                 end
        --                 if clone then
        --                     clone:Destroy()
        --                     weld:Destroy()
        --                 end
        --             end)
        --         end
        --     end
            -- Bar functionality: Disable E and Space keys if a certain "Meter" attribute is above a threshold
            if playerModel:GetAttribute("Guarding") then
                playerModel.Collider.CanCollide = false
        
                playerModel:GetAttributeChangedSignal("Guarding"):Connect(function()
                    if not playerModel:GetAttribute("Guarding") then
                        playerModel.Collider.CanCollide = true
                    end
                end)
            end

            if playerModel:GetAttribute("Screen") then
                -- Anchor the Collider
                playerModel.Collider.Anchored = true
            
                -- Listen for changes in the "Screen" attribute
                playerModel:GetAttributeChangedSignal("Screen"):Connect(function()
                    -- If the "Screen" attribute is off, unanchor the Collider
                    if not playerModel:GetAttribute("Screen") then
                        playerModel.Collider.Anchored = false
                    end
                end)
            end

            if playerModel:GetAttribute("UsingHandles") then
                local args = {
                    [1] = {
                        ["Action"] = "Post",
                        ["Val"] = true
                    }
                }
                
                game:GetService("ReplicatedStorage"):WaitForChild("Lib"):WaitForChild("EventsPlayer"):WaitForChild("Actions"):FireServer(unpack(args))
                local args = {
                    [1] = {
                        ["Action"] = "Boxout",
                        ["Val"] = true
                    }
                }
                
                game:GetService("ReplicatedStorage"):WaitForChild("Lib"):WaitForChild("EventsPlayer"):WaitForChild("Actions"):FireServer(unpack(args))                
                wait(0.3)
                local args = {
                    [1] = {
                        ["Action"] = "Post",
                        ["Val"] = false
                    }
                }
                
                game:GetService("ReplicatedStorage"):WaitForChild("Lib"):WaitForChild("EventsPlayer"):WaitForChild("Actions"):FireServer(unpack(args))          
                local args = {
                    [1] = {
                        ["Action"] = "Boxout",
                        ["Val"] = false
                    }
                }
                
                game:GetService("ReplicatedStorage"):WaitForChild("Lib"):WaitForChild("EventsPlayer"):WaitForChild("Actions"):FireServer(unpack(args))                
            end
        end
        wait(0.01) -- Slight yield for performance
    end
end)    